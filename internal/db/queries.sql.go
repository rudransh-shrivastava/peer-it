// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
)

const addPeerToSwarm = `-- name: AddPeerToSwarm :exec
INSERT INTO swarms (peer_id, file_id)
SELECT p.id, f.id
FROM peers p, files f
WHERE p.ip_address = ? AND p.port = ? AND f.hash = ?
`

type AddPeerToSwarmParams struct {
	IpAddress string
	Port      string
	Hash      string
}

func (q *Queries) AddPeerToSwarm(ctx context.Context, arg AddPeerToSwarmParams) error {
	_, err := q.db.ExecContext(ctx, addPeerToSwarm, arg.IpAddress, arg.Port, arg.Hash)
	return err
}

const createChunk = `-- name: CreateChunk :one
INSERT INTO chunks (file_id, chunk_index, chunk_size, chunk_hash, is_available)
VALUES (?, ?, ?, ?, ?)
RETURNING id, file_id, chunk_index, chunk_size, chunk_hash, is_available
`

type CreateChunkParams struct {
	FileID      int64
	ChunkIndex  int64
	ChunkSize   int64
	ChunkHash   string
	IsAvailable int64
}

// Chunk queries
func (q *Queries) CreateChunk(ctx context.Context, arg CreateChunkParams) (Chunk, error) {
	row := q.db.QueryRowContext(ctx, createChunk,
		arg.FileID,
		arg.ChunkIndex,
		arg.ChunkSize,
		arg.ChunkHash,
		arg.IsAvailable,
	)
	var i Chunk
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.ChunkIndex,
		&i.ChunkSize,
		&i.ChunkHash,
		&i.IsAvailable,
	)
	return i, err
}

const createFile = `-- name: CreateFile :one

INSERT INTO files (name, size, max_chunk_size, total_chunks, hash, created_at)
VALUES (?, ?, ?, ?, ?, ?)
RETURNING id, name, size, max_chunk_size, total_chunks, hash, created_at
`

type CreateFileParams struct {
	Name         string
	Size         int64
	MaxChunkSize int64
	TotalChunks  int64
	Hash         string
	CreatedAt    int64
}

// Queries for peer-it database
// File queries
func (q *Queries) CreateFile(ctx context.Context, arg CreateFileParams) (File, error) {
	row := q.db.QueryRowContext(ctx, createFile,
		arg.Name,
		arg.Size,
		arg.MaxChunkSize,
		arg.TotalChunks,
		arg.Hash,
		arg.CreatedAt,
	)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Size,
		&i.MaxChunkSize,
		&i.TotalChunks,
		&i.Hash,
		&i.CreatedAt,
	)
	return i, err
}

const createPeer = `-- name: CreatePeer :one
INSERT INTO peers (ip_address, port)
VALUES (?, ?)
RETURNING id, ip_address, port
`

type CreatePeerParams struct {
	IpAddress string
	Port      string
}

// Peer queries
func (q *Queries) CreatePeer(ctx context.Context, arg CreatePeerParams) (Peer, error) {
	row := q.db.QueryRowContext(ctx, createPeer, arg.IpAddress, arg.Port)
	var i Peer
	err := row.Scan(&i.ID, &i.IpAddress, &i.Port)
	return i, err
}

const createSwarm = `-- name: CreateSwarm :one
INSERT INTO swarms (peer_id, file_id)
VALUES (?, ?)
RETURNING id, peer_id, file_id
`

type CreateSwarmParams struct {
	PeerID int64
	FileID int64
}

// Swarm queries
func (q *Queries) CreateSwarm(ctx context.Context, arg CreateSwarmParams) (Swarm, error) {
	row := q.db.QueryRowContext(ctx, createSwarm, arg.PeerID, arg.FileID)
	var i Swarm
	err := row.Scan(&i.ID, &i.PeerID, &i.FileID)
	return i, err
}

const deleteAllPeers = `-- name: DeleteAllPeers :exec
DELETE FROM peers
`

func (q *Queries) DeleteAllPeers(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllPeers)
	return err
}

const deleteAllSwarms = `-- name: DeleteAllSwarms :exec
DELETE FROM swarms
`

func (q *Queries) DeleteAllSwarms(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllSwarms)
	return err
}

const deletePeerByIPPort = `-- name: DeletePeerByIPPort :exec
DELETE FROM peers WHERE ip_address = ? AND port = ?
`

type DeletePeerByIPPortParams struct {
	IpAddress string
	Port      string
}

func (q *Queries) DeletePeerByIPPort(ctx context.Context, arg DeletePeerByIPPortParams) error {
	_, err := q.db.ExecContext(ctx, deletePeerByIPPort, arg.IpAddress, arg.Port)
	return err
}

const getAllFiles = `-- name: GetAllFiles :many
SELECT id, name, size, max_chunk_size, total_chunks, hash, created_at FROM files
`

func (q *Queries) GetAllFiles(ctx context.Context) ([]File, error) {
	rows, err := q.db.QueryContext(ctx, getAllFiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Size,
			&i.MaxChunkSize,
			&i.TotalChunks,
			&i.Hash,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChunk = `-- name: GetChunk :one
SELECT c.id, c.file_id, c.chunk_index, c.chunk_size, c.chunk_hash, c.is_available FROM chunks c
JOIN files f ON c.file_id = f.id
WHERE f.hash = ? AND c.chunk_index = ?
LIMIT 1
`

type GetChunkParams struct {
	Hash       string
	ChunkIndex int64
}

func (q *Queries) GetChunk(ctx context.Context, arg GetChunkParams) (Chunk, error) {
	row := q.db.QueryRowContext(ctx, getChunk, arg.Hash, arg.ChunkIndex)
	var i Chunk
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.ChunkIndex,
		&i.ChunkSize,
		&i.ChunkHash,
		&i.IsAvailable,
	)
	return i, err
}

const getChunksByFileHash = `-- name: GetChunksByFileHash :many
SELECT c.id, c.file_id, c.chunk_index, c.chunk_size, c.chunk_hash, c.is_available FROM chunks c
JOIN files f ON c.file_id = f.id
WHERE f.hash = ?
ORDER BY c.chunk_index
`

func (q *Queries) GetChunksByFileHash(ctx context.Context, hash string) ([]Chunk, error) {
	rows, err := q.db.QueryContext(ctx, getChunksByFileHash, hash)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Chunk{}
	for rows.Next() {
		var i Chunk
		if err := rows.Scan(
			&i.ID,
			&i.FileID,
			&i.ChunkIndex,
			&i.ChunkSize,
			&i.ChunkHash,
			&i.IsAvailable,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChunksByFileID = `-- name: GetChunksByFileID :many
SELECT id, file_id, chunk_index, chunk_size, chunk_hash, is_available FROM chunks WHERE file_id = ? ORDER BY chunk_index
`

func (q *Queries) GetChunksByFileID(ctx context.Context, fileID int64) ([]Chunk, error) {
	rows, err := q.db.QueryContext(ctx, getChunksByFileID, fileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Chunk{}
	for rows.Next() {
		var i Chunk
		if err := rows.Scan(
			&i.ID,
			&i.FileID,
			&i.ChunkIndex,
			&i.ChunkSize,
			&i.ChunkHash,
			&i.IsAvailable,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFileByHash = `-- name: GetFileByHash :one
SELECT id, name, size, max_chunk_size, total_chunks, hash, created_at FROM files WHERE hash = ? LIMIT 1
`

func (q *Queries) GetFileByHash(ctx context.Context, hash string) (File, error) {
	row := q.db.QueryRowContext(ctx, getFileByHash, hash)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Size,
		&i.MaxChunkSize,
		&i.TotalChunks,
		&i.Hash,
		&i.CreatedAt,
	)
	return i, err
}

const getFileByID = `-- name: GetFileByID :one
SELECT id, name, size, max_chunk_size, total_chunks, hash, created_at FROM files WHERE id = ? LIMIT 1
`

func (q *Queries) GetFileByID(ctx context.Context, id int64) (File, error) {
	row := q.db.QueryRowContext(ctx, getFileByID, id)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Size,
		&i.MaxChunkSize,
		&i.TotalChunks,
		&i.Hash,
		&i.CreatedAt,
	)
	return i, err
}

const getFileNameByHash = `-- name: GetFileNameByHash :one
SELECT name FROM files WHERE hash = ? LIMIT 1
`

func (q *Queries) GetFileNameByHash(ctx context.Context, hash string) (string, error) {
	row := q.db.QueryRowContext(ctx, getFileNameByHash, hash)
	var name string
	err := row.Scan(&name)
	return name, err
}

const getPeerByIPPort = `-- name: GetPeerByIPPort :one
SELECT id, ip_address, port FROM peers WHERE ip_address = ? AND port = ? LIMIT 1
`

type GetPeerByIPPortParams struct {
	IpAddress string
	Port      string
}

func (q *Queries) GetPeerByIPPort(ctx context.Context, arg GetPeerByIPPortParams) (Peer, error) {
	row := q.db.QueryRowContext(ctx, getPeerByIPPort, arg.IpAddress, arg.Port)
	var i Peer
	err := row.Scan(&i.ID, &i.IpAddress, &i.Port)
	return i, err
}

const getPeersByFileHash = `-- name: GetPeersByFileHash :many
SELECT p.id, p.ip_address, p.port FROM peers p
JOIN swarms s ON p.id = s.peer_id
JOIN files f ON s.file_id = f.id
WHERE f.hash = ?
`

func (q *Queries) GetPeersByFileHash(ctx context.Context, hash string) ([]Peer, error) {
	rows, err := q.db.QueryContext(ctx, getPeersByFileHash, hash)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Peer{}
	for rows.Next() {
		var i Peer
		if err := rows.Scan(&i.ID, &i.IpAddress, &i.Port); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markChunkAvailable = `-- name: MarkChunkAvailable :exec
UPDATE chunks SET is_available = 1
WHERE file_id = (SELECT id FROM files WHERE hash = ?)
AND chunk_index = ?
`

type MarkChunkAvailableParams struct {
	Hash       string
	ChunkIndex int64
}

func (q *Queries) MarkChunkAvailable(ctx context.Context, arg MarkChunkAvailableParams) error {
	_, err := q.db.ExecContext(ctx, markChunkAvailable, arg.Hash, arg.ChunkIndex)
	return err
}
